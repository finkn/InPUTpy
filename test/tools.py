"""
test.tools

Tools that are useful for writing unit tests for InPUT.

Wherever possible, the test functions return as soon as a result is
available. This means that the iterations can usually be set quite high
without incurring any undue performance costs.

Functions with shortcuts: (exit as soon as possible)
- assertVariability             - Succeeds early
- assertGeneratesAny            - Succeeds early
- assertGeneratesAll            - Succeeds early
- assertConstancy               - Fails early
- assertGeneratesOnly           - Fails early
- assertMatchingArrayDimensions - Fails early *

* However, the array dimensions test is controlled by the input. It
doesn't have an iterations argument.

Nonsensical values for iterations are not allowed.
An example would be checking for variability by generating 1 value.

The assertGeneratesAll function uses a default number of iterations that
is proportional to the number of expected values.

:copyright: (c) 2013 by Christoffer Fink.
:license: MIT. See LICENSE for details.
"""

import warnings

DEFAULT_ITERATIONS = 20

def assertVariability(f, iterations=DEFAULT_ITERATIONS):
    """ Assert that f will generate at least one unique value. """
    assert iterations > 1, '1 iteration makes no sense!'
    values = []
    for i in range(iterations):
        value = f()
        if value not in values and len(values) > 0:
            return True     # Found a new value.
        else:
            values.append(value)
    msg = 'Only generated %s for %i iterations' % (value, iterations)
    raise AssertionError(msg)

def assertConstancy(f, iterations=DEFAULT_ITERATIONS):
    """ Assert that f will only generate a constant value. """
    assert iterations > 1, '1 iteration makes no sense!'
    values = []
    for i in range(iterations):
        value = f()
        if value not in values and len(values) > 0:
            msg = 'Generated a unique value after %i iterations' % (iterations)
            raise AssertionError(msg)
        else:
            values.append(value)
    return True             # No variation after N iterations.


def assertMatchingArrayDimensions(sizes, array):
    """
    Assert that the array dimensions match the given sizes.
    The sizes are listed in order of nesting, which implies that the
    sub-arrays on each level must be uniformly sized.
    """
    size = sizes[0]
    if size != len(array):
        msg = '%i does not match length of %s' % (size, array)
        raise AssertionError(msg)
    if len(sizes) == 1:
        return True         # No more dimensions. Done.
    for element in array:
        # Check sub-arrays recursively.
        assertMatchingArrayDimensions(sizes[1:], element)
    return True


def assertGeneratesAny(f, expected, iterations=DEFAULT_ITERATIONS):
    """ Assert that f generates at least one expected value. """
    for i in range(iterations):
        if f() in expected:
            return True
    msg = 'Generated none of %s after %i iterations' % (expected, iterations)
    raise AssertionError(msg)

def assertGeneratesAll(f, expected, iterations=None):
    """
    Assert that f generates all expected values.
    If given, iterations must be >= the number of expected values.
    """
    if iterations is None:
        iterations = len(expected) * DEFAULT_ITERATIONS
    else:
        msg = 'Must generate at least as many values as are expected'
        assert iterations >= len(expected), msg

    expected = list(expected)   # Defensive copy.
    for i in range(iterations):
        v = f()
        if v in expected:
            expected.remove(v)
        if len(expected) == 0:
            return True
    msg = '%s still missing after %i iterations' % (expected, iterations)
    raise AssertionError(msg)

def assertGeneratesOnly(f, expected, iterations=DEFAULT_ITERATIONS):
    """ Assert that only expected values are generated by f. """
    for i in range(iterations):
        v = f()
        if v not in expected:
            raise AssertionError('%s not in %s' % (v, expected))
    return True


def generatorFromDesignSpace(space, paramId):
    """
    Return a function that will return a new value for the parameter.
    """
    return lambda: space.next(paramId)

def finiteGeneratorFromSeq(seq):
    """
    Return a function that will return the next item in the list.
    When all items have been returned, subsequent attempts to generate
    a value will raise an IndexError.
    """
    seq = list(seq) # Defensive copy.
    seq.reverse()
    return lambda: seq.pop()

def generatorFromSeq(seq):
    """
    Return a function that will return the next item in the sequence.
    When all items have been returned, the sequence starts over.
    The returned function is an infinite generator.
    """
    seq = list(seq) # Defensive copy.
    seq.reverse()
    def gen():
        x = seq.pop()
        seq.insert(0, x)
        return x
    return gen
